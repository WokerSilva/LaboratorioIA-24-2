\documentclass[a4paper,12pt]{article} 
\usepackage[utf8]{inputenc} % Acentos válidos sin problemas
\usepackage[spanish]{babel} % Idioma

\usepackage[backend=biber, style=alphabetic, sorting=ynt]{biblatex}
\bibliography{bibliografia.bib}
\nocite{*} % Añade todas las referencias de bib sin cita

\input{packet}
\pagestyle{fancy}

\begin{document}%----------------------INICIO DOCUMENTO------------|
%------------------------------------------------------------------|
\input{portada}

\newpage

% ------------------------------------------------------------------------------|
% -----------------------------------------------------------------------------|
% ----------------------------------------------------------------------------|
\section{Documentación}
% ----------------------------------------------------------------------------\
% -----------------------------------------------------------------------------\
% ------------------------------------------------------------------------------\

\subsection{Forma de ejecutar}
\begin{itemize}
    \item Asegurarnos de tener instalada una de las siguientes versiones de python: \cite{docGym}
\begin{lstlisting}[language=bash]
    &\textcolor{rubber}{skynet}&: $ python --&\textcolor{codecommentTerminal}{version}&
    &\textcolor{rubber}{skynet}&: $  Python 3.7   
    &\textcolor{rubber}{skynet}&: $  Python 3.8
    &\textcolor{rubber}{skynet}&: $  Python 3.9
    &\textcolor{rubber}{skynet}&: $  Python 3.10
\end{lstlisting}
    Esto es para no tener problemas a la hora de trabajar con \texttt{gym}

    \item Vamos a la carpeta donde se encuentra el archivo \texttt{laberinto.py}
\begin{lstlisting}[language=bash]
    &\textcolor{rubber}{skynet}&: $ cd Practica02/src
    &\textcolor{rubber}{skynet}&: &\textcolor{Meadow}{Practica02/src}& $  ls         
    laberinto.py
\end{lstlisting}

    \item Instalar \texttt{gym}
\begin{lstlisting}[language=bash]    
    &\textcolor{rubber}{skynet}&: &\textcolor{Meadow}{Practica02/src}& $  pip install gym
\end{lstlisting}    

    \item Para ejecutar usaremos el siguiente comando
\begin{lstlisting}[language=bash]    
    &\textcolor{rubber}{skynet}&: &\textcolor{Meadow}{Practica02/src}& $  python laberinto.py    
\end{lstlisting}
\end{itemize}



\subsection{Código}

\subsubsection*{OpenAI gym}

gym: Librería de Python desarrollada por OpenAI, nos permite implementar diferentes 
algoritmos de aprendizaje por refuerzo y simular la interaccion entre agentes y entornos.

spaces: Define el formato válido de los espacios de observación y accion para un entorno.

Gym es una biblioteca Python de código abierto para desarrollar y comparar 
algoritmos de aprendizaje por refuerzo al proporcionar una API estándar 
para comunicarse entre algoritmos y entornos de aprendizaje, así como un 
conjunto estándar de entornos compatibles con esa API. \cite{docGym} \\



Los problemas de aprendizaje por refuerzo consisten en el agente y 
el entorno. El entorno proporciona retroalimentación al agente para 
que pueda aprender qué accion es apropiada para un estado específico.

\subsection{Cambios realizados}

\begin{center}
    \Large{Definición del agente}
\end{center}

\noindent Haciendo uso de la clase \textbf{Maze} que hereda de \texttt{gym} construimos 
nuestra clase para el \texttt{Agente} y el laberinto. Almacenando al mismo laberinto 
por su altura y anchura junto con las lineas de movimiento con todos los estados posibles 
dentro del laberinto, también se inicializa un posicion para el agente y una operación 
que nos indica si se esta ejecutando o a finalizado.

\begin{lstlisting}[style=mystylepython, language=Python, caption= Definición del agente]
# Representar el entorno del laberinto
class Maze(gym.Env):
    
    def __init__(self, maze):
        super(Maze, self).__init__()
        # Almacena el laberinto
        self.maze = maze  
        # Almacena la altura del laberinto
        self.height = len(maze)  
        # Almacena la anchura del laberinto
        self.width = len(maze[0])  
        # Espacio de accion del agente: arriba, abajo, izquierda, derecha
        self.action_space = spaces.Discrete(4)  
        # Espacio de observacion (posibles estados que el agente puede observar del entorno)
        self.observation_space = spaces.Discrete(self.height * self.width) 
        self.agent_pos = None  # Posicion inicial 
        self.done = False  # Indica si el episodio ha terminado (interacciones entre el agente y el entorno )
\end{lstlisting}

\noindent El método \texttt{reset} básicamente reinicia el laberinto con la finalidad 
de que en cada llamada el agente se encuentre en su poción inicial correcta. Lo hace 
llamando al agente y asignándole la posición y terminando la interacción agente laberinto.

\begin{center}
    \Large{Movimientos del agente}
\end{center}

\begin{lstlisting}[style=mystylepython, language=Python, caption= metodo reset]
    # Reinicia el entorno a su estado inicial y devuelve la posicion inicial del agente.
    def reset(self):
        # Se busca la posicion de inicio en el laberinto
        self.agent_pos = self.find_start() 
        # Reinicia el estado de finalizacion del episodio
        self.done = False  
        return self.agent_pos
\end{lstlisting}        


\noindent El método \texttt{step} (similar al método \textit{mover}) es el encargado de 
hacer que nuestro agente tome las direcciones arriba, abajo, izquierda, derecha. Primero 
comprobando el valor de self.done para saber si ha terminado, si es así, regresa a la 
posición actual del agente sin realizar ningún movimiento adicional. Se toman las 
coordenadas $x$, $y$, que son las actuales del agente, con \textit{action} se verifica que 
dirección quiere tomar, si es valida actualiza la posición del agente y vuelve verificar 
pero esta vez si es que la poción es la de salida marcando un True. Finalmente, 
regresa la nueva posición del agente, una recompensa de 0, el estado de finalización 
del episodio y un diccionario vacío.

\begin{lstlisting}[style=mystylepython, language=Python, caption= metodo step]
    # Toma una accion y se mueve un paso en el entorno.
    def step(self, action):
        if self.done:
            # Si el episodio ya ha terminado, regresamos a la posicion actual
            return self.agent_pos, 0, True, {}
    
        x, y = self.agent_pos
    
        # Movimientos posibles: arriba, abajo, izquierda, derecha
        if action == 0 and x > 0 and self.maze[x - 1][y] != 1:
            print("Movimiento: arriba")
            x -= 1
        elif action == 1 and x < self.height - 1 and self.maze[x + 1][y] != 1:
            print("Movimiento: abajo")
            x += 1
        elif action == 2 and y > 0 and self.maze[x][y - 1] != 1:
            print("Movimiento: izquierda")
            y -= 1
        elif action == 3 and y < self.width - 1 and self.maze[x][y + 1] != 1:
            print("Movimiento: derecha")
            y += 1
    
        self.agent_pos = (x, y)
    
        # Verifica si la posicion en la que se encuentra es la salida
        if self.maze[x][y] == "S":
            self.done = True
    
        return self.agent_pos, 0, self.done, {}
\end{lstlisting}        

Con este método vamos iterando por lo alto y ancho del laberinto para la búsqueda de la 
poción inicial del agente, ya que nos adelantamos a que no siempre será la poción $(0.0)$, 
de esta forma el agente inicia en la poción correcta el laberinto cada vez que se llama 
a \texttt{reset}, además garantiza que que exista un punto de inicio.

\begin{lstlisting}[style=mystylepython, language=Python, caption= metodo find start]        
    # Encuentra la posicion inicial del agente (entrada del laberinto).
    def find_start(self):
        for i in range(self.height):
            for j in range(self.width):
                if self.maze[i][j] == "E":
                    return (i, j)
        raise ValueError("No se pudo encontrar el punto de inicio E en el laberinto")
\end{lstlisting}

\begin{center}
    \Large{El algoritmo}
\end{center}

Ahora si, la carne dentro del código, la salida usando backtracking. el método \texttt{solve} comienza por 
definir los 4 movimientos del agente por las tuplas de las coordenadas 

\begin{lstlisting}[style=mystylepython, language=Python, caption= Movimientos del agente]
# Encuentra la salida usando backtracking
    def solve(env):
        # arriba, abajo, izquierda, derecha
        actions = [(0, -1), (0, 1), (-1, 0), (1, 0)]  
\end{lstlisting}

Ya definidos los movimientos pasamos a verificar que nuestro agente no traspasará muros o hará un 
recorridos al puro estilo pacman:
\begin{itemize}
    \item Primero verificamos si las coordenadas están fuera de los límites del laberinto.
    \item Si no hemos topado con un muro
    \item Si el agente ya ha pasado por esta celda en la ruta actual \texttt{((x, y) in path)}
\end{itemize}

\begin{lstlisting}[style=mystylepython, language=Python, caption= Validación de movimientos]
        def backtrack(x, y, path):
            if x < 0 or x >= env.height or y < 0 or y >= env.width or env.maze[x][y] == 1 or (x, y) in path:
                return False
    
            path.append((x, y))
\end{lstlisting}

Después vamos a verificar si la poción es la salida. Si es así imprimimos que se ha encontrado y 
se devuelve True para indicar que se ha encontrado la salida.

Recursivamente llamamos a \texttt{backtrack} para iterar sobre todos los movimientos posibles en 
la posición actual. Busca los caminos y si no llega a la salida retrocede con el \texttt{path.pop()}. Y como 
antes lo explicábamos en el método buscamos la poción inicial, la usamos para encontrar la $x$ y $y$ y se las
pasamos al método \texttt{backtrack}, de esta forma de itera para ir imprimiendo la ruta que siguió el 
agente o si no hay SOLUCION nos lo hace saber el programa. 

\begin{lstlisting}[style=mystylepython, language=Python, caption= algoritmo backtracking]
            if env.maze[x][y] == "S":
                print("Encontre la salida :D")
                return True
    
            for action in range(env.action_space.n):
                if backtrack(x + actions[action][0], y + actions[action][1], path):
                    return True
    
            path.pop()
            return False
    
        start_x, start_y = env.find_start()
        path = []
        if backtrack(start_x, start_y, path):
            print("La ruta es:")
            for i, pos in enumerate(path):
                x, y = pos
                direction = ""
                if i > 0:
                    # Comparar la posicion actual con la anterior para determinar la direccion
                    prev_pos = path[i - 1]
                    if x < prev_pos[0]:
                        direction = "arriba"
                    elif x > prev_pos[0]:
                        direction = "abajo"
                    elif y < prev_pos[1]:
                        direction = "izquierda"
                    elif y > prev_pos[1]:
                        direction = "derecha"
                print(f"Posicion: {pos}, Direccion: {direction}")
        else:
            print("iiiiii no encontre la salida")
\end{lstlisting}

Vamos a ver más de cerca esta linea: Tenemos una llamada recursiva a \texttt{backtrack}, y nos posicionamos en 
$x$ y $y$ coordenadas actuales donde \texttt{actions} hace los movimientos correspondientes al momento de hacer 
volver a llamar al método le estamos pasamos esas coordenadas y la lista de posiciones visitadas hasta el 
momento. La condicional verifica la llamada, pues si es True ya se encontró la salida pero si devuelve un 
False, no ha encontrado la salida y lo que hace es retroceder eliminando la posición de la lista.

\begin{lstlisting}[style=mystylepython, language=Python, caption= algoritmo backtracking]
    if backtrack(x + actions[action][0], y + actions[action][1], path):
\end{lstlisting}


\begin{center}
    \Large{Código extra}
\end{center}

Como extra hemos añadido 6 laberintos para ejecutar nuestras pruebas


\begin{minipage}[t]{8.2cm}
\begin{lstlisting}[style=mystylepython, language=Python, caption= laberinto01]
    # Laberinto 01 CON SOLUCION
laberinto01 = [
    ["E", 0, 1, 0,   0, 0, 0, 0],
    [  0, 0, 1, 0,   1, 0, 1, 0],
    [  0, 0, 1, 0, "S", 0, 1, 1],
    [  0, 0, 0, 0,   1, 1, 0, 0],
    [  1, 0, 1, 1,   1, 1, 1, 0],
    [  0, 0, 0, 0,   0, 0, 1, 0],
    [  0, 1, 1, 1,   1, 1, 1, 0],
    [  0, 0, 0, 0,   0, 0, 0, 0]
]
\end{lstlisting}
\end{minipage}
\hspace{9mm}
\begin{minipage}[t]{8.2cm}
\begin{lstlisting}[style=mystylepython, language=Python, caption= laberinto02]
    # Laberinto 02 CON SOLUCION
    laberinto02 = [
        ["E", 0, 0,   0, 0, 0, 0, 0],
        [  0, 0, 1,   0, 1, 0, 1, 0],
        [  0, 0, 1,   0, 1, 0, 1, 1],
        [  0, 0, 0,   0, 1, 1, 1, 0],
        [  1, 0, 1,   1, 1, 1, 1, 0],
        [  0, 0, 0,   0, 0, 0, 0, 1],
        [  0, 1, 1,   1, 0, 0, 0, 0],
        [  0, 0, 0, "S", 0, 0, 1, 1]
    ]
\end{lstlisting}
\end{minipage} \\

\begin{minipage}[t]{8.2cm}
\begin{lstlisting}[style=mystylepython, language=Python, caption= laberinto03]
    # Laberinto 03 SIN SOLUCION
    # No hay camino
    laberinto03 = [
        ["E", 1],
        [1, "S"]
    ]
    
\end{lstlisting}
\end{minipage}
\hspace{9mm}
\begin{minipage}[t]{8.2cm}
\begin{lstlisting}[style=mystylepython, language=Python, caption= laberinto04]
    # Laberinto 04 SIN SOLUCION
    # No hay salida
    laberinto04 = [
        ["E", 0, 0, 0, 0, 0, 0, 0],
        [  0, 0, 1, 0, 1, 0, 1, 0],
        [  0, 0, 1, 0, 1, 0, 1, 1],
        [  0, 0, 0, 0, 1, 1, 1, 0],
        [  1, 0, 1, 1, 1, 1, 1, 0],
        [  0, 0, 0, 0, 0, 0, 0, 1],
        [  0, 1, 1, 1, 0, 0, 0, 0],
        [  0, 0, 0, 1, 0, 0, 1, 1]
    ]
\end{lstlisting}
\end{minipage} \\ 

\begin{minipage}[t]{8.2cm}
\begin{lstlisting}[style=mystylepython, language=Python, caption= laberinto05]
    # Laberinto 05 SIN SOLUCION
    # No hay entrada
    laberinto05 = [
        [ 1, 0, 1, 0,   0, 0, 0, 0],
        [ 0, 0, 1, 0,   1, 0, 1, 0],
        [ 0, 0, 1, 0, "S", 0, 1, 1],
        [ 0, 0, 0, 0,   1, 1, 0, 0],
        [ 1, 0, 1, 1,   1, 1, 1, 0],
        [ 0, 0, 0, 0,   0, 0, 1, 0],
        [ 0, 1, 1, 1,   1, 1, 1, 0],
        [ 0, 0, 0, 0,   0, 0, 0, 0]
    ]    
\end{lstlisting}
\end{minipage}
\hspace{9mm}
\begin{minipage}[t]{8.2cm}
\begin{lstlisting}[style=mystylepython, language=Python, caption= laberinto06]
    # Laberinto 02 CON SOLUCION
    laberinto06 = [
        ["E", 0, 0,   0, 0, 0, 0, 0],
        [  0, 0, 1,   0, 1, 0, 1, 0],
        [  0, 0, 1,   0, 1, 0, 1, 1],
        [  0, 0, 0,   0, 1, 1, 1, 0],
        [  1, 0, 1,   1, 1, 1, 1, 0],
        [  0, 0, 0,   0, 0, 0, 0, 1],
        [  0, 1, 1,   1, 0, 0, 0, 0],
        [  0, 0, 2, "S", 0, 0, 1, 1]
    ]
\end{lstlisting}
\end{minipage}


% ----------------------|
% Referencias           |
% Forma de Compilar     |
% pdflatex main.tex     |
% biber main            |
% pdflatex main.tex     |
\newpage %              |
\thispagestyle{fancyref}
\printbibliography %    |
% ----------------------|

\end{document}%----------------------F I N DOCUMENTO---------------|
%------------------------------------------------------------------|
